<!DOCTYPE html><html><head><title>R: Create a tibble from all combinations of inputs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table style="width: 100%;"><tr><td>expand_grid {tidyr}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2 id='expand_grid'>Create a tibble from all combinations of inputs</h2>

<h3>Description</h3>

<p><code>expand_grid()</code> is heavily motivated by <code><a href="../../base/html/expand.grid.html">expand.grid()</a></code>.
Compared to <code>expand.grid()</code>, it:
</p>

<ul>
<li><p> Produces sorted output (by varying the first column the slowest, rather
than the fastest).
</p>
</li>
<li><p> Returns a tibble, not a data frame.
</p>
</li>
<li><p> Never converts strings to factors.
</p>
</li>
<li><p> Does not add any additional attributes.
</p>
</li>
<li><p> Can expand any generalised vector, including data frames.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>expand_grid(..., .name_repair = "check_unique")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_grid_:_...">...</code></td>
<td>
<p>Name-value pairs. The name will become the column name in the
output.</p>
</td></tr>
<tr><td><code id="expand_grid_:_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic column names:
</p>

<ul>
<li> <p><code>"minimal"</code>: No name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code>"unique"</code>: Make sure names are unique and not empty,
</p>
</li>
<li> <p><code>"check_unique"</code>: (default value), no name repair, but check they are
<code>unique</code>,
</p>
</li>
<li> <p><code>"universal"</code>: Make the names <code>unique</code> and syntactic
</p>
</li>
<li><p> a function: apply custom name repair (e.g., <code>.name_repair = make.names</code>
for names in the style of base R).
</p>
</li>
<li><p> A purrr-style anonymous function, see <code><a href="../../rlang/help/as_function.html">rlang::as_function()</a></code>
</p>
</li></ul>

<p>This argument is passed on as <code>repair</code> to <code><a href="../../vctrs/help/vec_as_names.html">vctrs::vec_as_names()</a></code>.
See there for more details on these terms and the strategies used
to enforce them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with one column for each input in <code>...</code>. The output
will have one row for each combination of the inputs, i.e. the size
be equal to the product of the sizes of the inputs. This implies
that if any input has length 0, the output will have zero rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expand_grid(x = 1:3, y = 1:2)
expand_grid(l1 = letters, l2 = LETTERS)

# Can also expand data frames
expand_grid(df = tibble(x = 1:2, y = c(2, 1)), z = 1:3)
# And matrices
expand_grid(x1 = matrix(1:4, nrow = 2), x2 = matrix(5:8, nrow = 2))
</code></pre>

<hr /><div style="text-align: center;">[Package <em>tidyr</em> version 1.3.0 <a href="00Index.html">Index</a>]</div>
</div>
</body></html>
